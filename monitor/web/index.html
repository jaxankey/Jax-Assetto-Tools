<html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  
  <title>Laps!</title>
  <style>

    * {
      padding: 0;
      margin : 0;
      font-family: Arial, Helvetica, sans-serif;
      font-size: 1em;
      font-weight: normal;
      color: #FEE;
      border-radius: 0;
    }

    body {
      height: 100%;
      background-color: #222;
      padding: 1em;
      bottom: 0;
    }
    #main {
      padding-bottom: 1em;
    }

    h1 {font-size: 2em;}
  
    select, td {
      padding: 0.5em;
      background: transparent;
      border: 1px solid #FEE;
      margin-top: 0.5em;
      margin-right: 0.5em;
    }
    select:focus {
      outline: none;
    }
    select option {
      color: #000;
    }

    table {
      margin-top: 0.5em;
      border: none;
      border-collapse: collapse;
    }
    
    tr:nth-child(odd) {background: #FF777733;}

    td {
      background: transparent;
    }
  

  </style>
  <link rel="shortcut icon" type="image/ico" href="images/favicon.ico" />
</head>
<body>

<div id='main'>
<select id='select_tracks' onchange='update_table()'></select>
<br><select id='select_mode'   onchange='update_table()'>
  <option value='All Laps'>All Laps</option>
  <option value='Best Per Driver'>Driver Best</option>
</select><input type='checkbox' id='checkbox_naughties' onchange='update_table()'>&nbsp;Naughties</input>

<table id='table_laps'></table>
</div> 


<script>

// Globals. Yeah, whatever.
var tracks             = []
var track_count        = 0
var select_track       = document.getElementById('select_tracks')
var select_mode        = document.getElementById('select_mode')
var table_laps         = document.getElementById('table_laps')
var checkbox_naughties = document.getElementById('checkbox_naughties')
/**
 * In-place sorts the supplied list of objects by the specified key.
 * @param {list} objects 
 * @param {string} key 
 * @param {boolean} descending 
 * @returns 
 */
function sort_objects_by_key(objects, key, descending) {

  // If increasing
  if(!descending) objects.sort(function(p1,p2) {return p1[key]-p2[key];});

  // If descending
  else            objects.sort(function(p1,p2) {return p2[key]-p1[key];});
    
  // All done.
  return objects
}

// Retrieves a file's contents
function get_data_from_url(url, handler) {
  console.log('get_data_from_url', url, '...');

  // Default handler
  if(handler == undefined) handler = console.log  

  // Now get the data from the URL in a reasonably cross-browser way
  if (window.XMLHttpRequest) var xmlhttp = new XMLHttpRequest();                   // Code for IE7+, Firefox, Chrome, Opera, Safari
  else                       var xmlhttp = new ActiveXObject("Microsoft.XMLHTTP"); // Code for IE6, IE5 (gross)
  
  // Set up the handler for when the process reaches its conclusion
  xmlhttp.onload = function() { if (xmlhttp.status==200) handler(xmlhttp.responseText, url); };
  
  // Start the process
  xmlhttp.open("GET", url);
  xmlhttp.send(); 
}   

// Gets tracks list from archive folder html page
function get_tracks(raw) { console.log('get_tracks()')

  // Reset the tracks database
  tracks.length = 0
  track_count   = 0

  // Split by li> and remove the first and last elements
  var s = raw.split('li>')

  // Every odd element is a track list item
  for(var n=1; n<s.length; n+=2) {
    
    // Increment the count
    track_count++

    // ... with <a href="trackname.json">, so we exploit that.
    var p = s[n].split('"')[1]

    // Load the data for this track
    get_data_from_url('archive/'+p, parse_track_json)
  }
}

// Parse the track json contents
function parse_track_json(raw, url) {
  
  // Parse the string into an object
  var data = JSON.parse(raw)
  data['url'] = url
  
  // From the url, get the date stamp
  data['timestamp'] = unescape(url).split('/')[1].split('.')[0]

  // Add it to the tracks dictionary
  tracks.push(data)
  console.log('parse_track_json()', data);

  // If we hit the track count, sort and initialize
  if(tracks.length >= track_count) initialize();
}

// Initializes with the data in tracks
function initialize() {
  console.log('initialize()')

  // Sort the tracks by track_name
  sort_objects_by_key(tracks, 'timestamp')

  // Loop over the tracks, adding the
  for(var n in tracks) {
    var o = document.createElement('option')
    o.value = o.text = tracks[n]['timestamp'] +' '+ tracks[n]['track_name']
    select_track.appendChild(o)
  }

  // Now load the current / last state.json
  get_data_from_url('state.json', choose_current_track)
}

// Takes the data from state.json and chooses the track from select
function choose_current_track(raw) {
  
  var data = JSON.parse(raw)
  select_tracks.value = data['archive_path'].split('/')[2].split('.')[0] +' '+data['track_name']
  console.log('choose_current_track()', select_tracks.value)

  // Fill the table
  update_table()
}

// When someone selects a track
function update_table() {

  // Get the track index. This should match that of the tracks list
  var t = select_track.selectedIndex
  console.log('update_table()', tracks[t])

  // Get just the laps for easy coding
  // Structure: tracks[t]['laps'][name][car] = {'time':'13:23:344', time_ms:1234567, 'cuts':0}
  // Or       : tracks[t]['naughties']... for the same structure
  var laps      = tracks[t]['laps']
  var naughties = tracks[t]['naughties']

  // Get the good laps
  // Structure: sorted = [{name:.., car:.., time:.., time_ms:..}, ...]
  sorted = get_laps(laps)
  
  // If we're supposed to include naughties, do so
  if(checkbox_naughties.checked) sorted = sorted.concat(get_laps(naughties))

  // Sort them by time
  sort_objects_by_key(sorted, 't_ms')
  console.log(sorted)

  // Now add this to the table!
  table_laps.innerHTML = '';

  // Add the titles


  // Add the data
  for(var i in sorted) {
    var row = table_laps.insertRow()
    var c_i = row.insertCell(0)
    var c_t = row.insertCell(1)
    var c_c = row.insertCell(2)
    var c_n = row.insertCell(3)

    //c_i.style.textAlign='right'

    c_i.innerText = parseInt(i)+1 + '.'
    c_t.innerText = sorted[i]['time']
    c_c.innerText = sorted[i]['car']
    c_n.innerText = sorted[i]['name']

    if(1 == sorted[i]['cuts']) c_t.innerText = c_t.innerText + ' (' + String(sorted[i]['cuts']) + '\u00a0cut)'
    else if(sorted[i]['cuts']) c_t.innerText = c_t.innerText + ' (' + String(sorted[i]['cuts']) + '\u00a0cuts)'
  }
}

// Returns a sorted list of best laps
function get_laps(laps) {
  
  // Loop over the people and assemble a list of laps
  var sorted = []
  for(var n in laps) {
    console.log('  ', n)

    // If we're supposed to find the fastest car for this name
    if(select_mode.selectedIndex == 1) {
      
      // Find the car with the minimum time
      var c = Object.keys(laps[n]).reduce((a,b) => laps[n][a]['time_ms'] < laps[n][b]['time_ms'] ? a : b)
      sorted.push({name:n, car:c, time:laps[n][c]['time'], t_ms:laps[n][c]['time_ms'], cuts:laps[n][c]['cuts']})
    }
    
    // Otherwise add all the car bests.
    else for(var c in laps[n]) {
      console.log('    ', c, laps[n][c])
      sorted.push({name:n, car:c, time:laps[n][c]['time'], t_ms:laps[n][c]['time_ms'], cuts:laps[n][c]['cuts']})
    }
  }
  return sorted
}



// Load the track laps data...
get_data_from_url('/archive', get_tracks)


</script>

</body>
</html>
