#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import glob, codecs, os, shutil, random, json, pyperclip, webbrowser, stat, pprint
import spinmob.egg as egg
egg.gui.egg_settings_path = os.path.join(egg.settings.path_home, 'ac_server_uploader')

# Change to the directory of this script
os.chdir(os.path.dirname(os.path.abspath(__file__)))
print('WORKING DIRECTORY:')
print(os.getcwd())

# Function for loading a json at the specified path
def load_json(path):
    """
    Load the supplied path with all the safety measures and encoding etc.
    """
    try:
        if os.path.exists(path):
            f = open(path, 'r', encoding='utf8')
            j = json.load(f, strict=False)
            f.close()
            return j
    except Exception as e:
        print('ERROR: Could not load', path)
        print(e)

def rmtree(top):
    """
    Implemented to take care of chmodding
    """
    for root, dirs, files in os.walk(top, topdown=False):
        for name in files:
            filename = os.path.join(root, name)
            os.chmod(filename, stat.S_IWUSR)
            os.remove(filename)
        for name in dirs:
            os.rmdir(os.path.join(root, name))
    os.rmdir(top)

# GUI class for configuring the server
class uploader():
    """
    GUI class for uploading content and restarting the assetto server.
    """

    def __init__(self, blocking=True):

        # For troubleshooting.
        self.timer_exceptions = egg.gui.TimerExceptions()        

        # Flag for whether we're in the init phase
        self._init = True

        ######################
        # Set the working directory to that of the script
        a = os.path.abspath(__file__)
        d = os.path.dirname(a)
        os.chdir(d)

        # Make sure we have a carset folder
        if not os.path.exists('carsets'): os.mkdir('carsets')

        # Other variables
        self.track = dict()
        self.style_category = 'color:blue; font-size:14pt; font-weight:bold'
        self.style_fancybutton = 'background-color: blue; color: white; font-weight:bold'



        ######################
        # Build the GUI

        # Main window
        self.window = egg.gui.Window('Assetto Corsa Uploader', size=(1200,700), autosettings_path='window')

        # Tabs
        self.tabs = self.window.add(egg.gui.TabArea(autosettings_path='tabs'))
        self.tab_settings = self.tabs.add('Settings')
        self.tab_uploader = self.tabs.add('Uploader')

        # Log
        self.text_log = self.window.add(egg.gui.TextLog())
        self.text_log.append_text('Welcome to AC Uploader!\n')



        #######################
        # SETTINGS

        # Server stuff
        self.tab_settings.new_autorow()
        self.tab_settings.add(egg.gui.Label('Mode:'))
        self.combo_mode = self.tab_settings.add(egg.gui.ComboBox(['Steam acServer', 'Server Manager'], 
            autosettings_path='combo_mode', signal_changed=self._combo_mode_changed))
 
        self.tab_settings.new_autorow()
        self.tab_settings.add(egg.gui.Label('Login:'))
        self.text_login = self.tab_settings.add(egg.gui.TextBox('username@ec2-or-whatever.compute.amazonaws.com', 
            tip='Your server\'s ssh username@ssh-web-address',
            autosettings_path='text_login'), alignment=0)
        
        self.tab_settings.new_autorow()
        self.tab_settings.add(egg.gui.Label('Port:'))
        self.text_port = self.tab_settings.add(egg.gui.TextBox('22', 
            tip='SSH Port (default is 22)',
            autosettings_path='text_port'), alignment=0)
        
        self.tab_settings.new_autorow()
        self.tab_settings.add(egg.gui.Label('keyfile.pem:'))
        self.text_pem          = self.tab_settings.add(egg.gui.TextBox('C:\\path\\to\\whatever.pem',
            tip='Local path to your key (*.pem) file generated by the server.',
            autosettings_path='text_pem'), alignment=0)
        self.button_browse_pem = self.tab_settings.add(egg.gui.Button('Browse', 
            tip='Opens a dialog to let you find the key (*.pem) file.',
            signal_clicked=self._button_browse_pem_clicked))

        self.tab_settings.new_autorow()
        self.tab_settings.add(egg.gui.Label('Local Assetto Path:'))
        self.text_local          = self.tab_settings.add(egg.gui.TextBox('C:\\path\\to\\assettocorsa',
            tip='Local path to assettocorsa folder.', autosettings_path='text_local'), alignment=0)
        self.button_browse_local = self.tab_settings.add(egg.gui.Button('Browse',
            tip='Opens a dialog to let you find the local assettocorsa folder.',
            signal_clicked=self._button_browse_local_clicked))

        self.tab_settings.new_autorow()
        self.tab_settings.add(egg.gui.Label('Remote Assetto Path:'))
        self.text_remote = self.tab_settings.add(egg.gui.TextBox('/home/username/path/to/assettocorsa',
            tip='Remote path to assettocorsa folder (where acServer is located).', 
            autosettings_path='text_remote'), alignment=0)

        ####### Settings for server manager premium
        self.tab_settings.new_autorow()
        self.label_stop = self.tab_settings.add(egg.gui.Label('Stop Server Command:'))
        self.text_stop = self.tab_settings.add(egg.gui.TextBox('/home/username/stop-server',
            tip='Remote path to a script that stops the server prior to modifying / uploading.', 
            autosettings_path='text_stop'), alignment=0)

        self.tab_settings.new_autorow()
        self.label_start = self.tab_settings.add(egg.gui.Label('Start Server Command:'))
        self.text_start = self.tab_settings.add(egg.gui.TextBox('/home/username/start-servers',
            tip='Remote path to a script that starts the server.', 
            autosettings_path='text_start'), alignment=0)

        self.tab_settings.new_autorow()
        self.label_monitor = self.tab_settings.add(egg.gui.Label('Restart Monitor Command:'))
        self.text_monitor = self.tab_settings.add(egg.gui.TextBox('/home/username/restart-monitor',
            tip='Remote path to a script that restarts the monitor.', 
            autosettings_path='text_monitor'), alignment=0)

        self.tab_settings.new_autorow()
        self.label_remote_championship = self.tab_settings.add(egg.gui.Label('Remote Championship JSON:'))
        self.text_remote_championship = self.tab_settings.add(egg.gui.TextBox('/home/username/server-manager/json/championships/blah-blah-blah.json',
            tip='Remote path to the championship json we wish to update. Requires json mode in\nserver-manager\'s config.yml.', 
            autosettings_path='text_remote_championship'), alignment=0)

        self.tab_settings.set_row_stretch(20)

        self.tab_settings.new_autorow()
        self.tab_settings.add(egg.gui.Label('Post-Upload URL:'))
        self.text_url = self.tab_settings.add(egg.gui.TextBox('',
            tip='Website to open when uploading, for example a place to modify the car selection on the reservation sheet, or a place to upload files for everyone else.',
            autosettings_path='text_url'), alignment=0)

        self.tab_settings.new_autorow()
        self.tab_settings.add(egg.gui.Label('Pre-Command:'))
        self.text_precommand = self.tab_settings.add(egg.gui.TextBox('',
            tip='Command to run before everything begins.',
            autosettings_path='text_precommand'), alignment=0)

        self.tab_settings.new_autorow()
        self.tab_settings.add(egg.gui.Label('Post-Command:'))
        self.text_postcommand = self.tab_settings.add(egg.gui.TextBox('',
            tip='Command to run after everything is done.',
            autosettings_path='text_postcommand'), alignment=0)



        #############################
        # UPLOADER
        self.tab_uploader.set_row_stretch(5)

        # Refresh button
        self.button_refresh = self.tab_uploader.add(egg.gui.Button('Refresh Tracks and Cars',
            tip='Scans the assettocorsa folder for content.',
            signal_clicked=self._button_refresh_clicked), alignment=0)
        self.button_refresh.set_style(self.style_fancybutton)

        self.tab_uploader.new_autorow()
        self.tab_uploader.add(egg.gui.Label('\nTrack').set_style(self.style_category))

        self.tab_uploader.new_autorow()
        self.grid2a = self.tab_uploader.add(egg.gui.GridLayout(False))

        # Track combo
        self.combo_tracks  = self.grid2a.add(egg.gui.ComboBox([],
            tip='Select a track!', 
            signal_changed=self._combo_tracks_changed ), alignment=0).set_minimum_width(200)
        self.combo_layouts = self.grid2a.add(egg.gui.ComboBox([],
            tip='Select a layout (if there is one)!',
            signal_changed=self._combo_layouts_changed), alignment=0).set_minimum_width(200)
        self.label_pitboxes= self.grid2a.add(egg.gui.Label('(0 pit boxes)'))

        # Grid for car controls (save/load, etc)
        self.tab_uploader.new_autorow()
        self.tab_uploader.add(egg.gui.Label('\nCars').set_style(self.style_category))
        self.tab_uploader.new_autorow()
        self.grid2b = self.tab_uploader.add(egg.gui.GridLayout(False), alignment=0)

        # Save load buttons
        self.combo_carsets = self.grid2b.add(egg.gui.ComboBox(['[New Carset]'],
            tip='Select a carset (if you have one saved)!'), alignment=0)
        self.grid2b.set_column_stretch(0)
        self.button_load = self.grid2b.add(egg.gui.Button('Load',
            tip='Load the selected carset.', signal_clicked=self._button_load_clicked))
        self.button_save = self.grid2b.add(egg.gui.Button('Save',
            tip='Save / overwrite the selected carset with the selection below.\nIf [New Carset] is selected, this pops up a dialog to name the carset.',
            signal_clicked=self._button_save_clicked))
        self.button_delete = self.grid2b.add(egg.gui.Button('Delete',
            tip='Delete the selected carset.',
            signal_clicked=self._button_delete_clicked))

        # Grid for car list
        self.tab_uploader.new_autorow()
        self.grid2c = self.tab_uploader.add(egg.gui.GridLayout(False), alignment=0)

        # Car list
        self.list_cars = self.grid2c.add(egg.pyqtgraph.QtGui.QListWidget(), alignment=0, column_span=3)
        self.list_cars.setSelectionMode(egg.pyqtgraph.QtGui.QAbstractItemView.ExtendedSelection)
        self.list_cars.itemSelectionChanged.connect(self._list_cars_changed)

        # Server stuff
        self.tab_uploader.new_autorow()
        self.tab_uploader.add(egg.gui.Label('\nServer').set_style(self.style_category))
        self.tab_uploader.new_autorow()

        self.grid2s = self.tab_uploader.add(egg.gui.GridLayout(margins=False), alignment=0)
        self.grid2s.add(egg.gui.Label('Max Pit Boxes:'))
        self.number_slots = self.grid2s.add(egg.gui.NumberBox(16,
            tip='Maximum number of pitboxes (will not exceed the track limit).', 
            bounds=(1,None), int=True, autosettings_path='number_slots'))

        # Actions
        self.checkbox_modify  = self.grid2s.add(egg.gui.CheckBox(
            'Config', autosettings_path='checkbox_modify', 
            tip='Modify the server files with the above configuration.'))
        self.checkbox_package = self.grid2s.add(egg.gui.CheckBox(
            'Content', autosettings_path='checkbox_package', 
            tip='Package up all the local files for upload.'))
        self.checkbox_upload  = self.grid2s.add(egg.gui.CheckBox(
            'Upload', autosettings_path='checkbox_upload', 
            tip='Upload to server and unpack.'))
        self.checkbox_clean = self.grid2s.add(egg.gui.CheckBox(
            'Clean Server', autosettings_path='checkbox_clean', 
            signal_changed=self._checkbox_clean_changed,
            tip='During upload, remove all old content (cars and tracks) from the server.'))
        self.checkbox_restart = self.grid2s.add(egg.gui.CheckBox(
            'Restart Server', autosettings_path='checkbox_restart', 
            tip='Stop the server before upload and restart after upload.'))
        self.checkbox_monitor = self.grid2s.add(egg.gui.CheckBox(
            'Restart Monitor', autosettings_path='checkbox_monitor', 
            tip='Restart the monitor after upload and server restart.'))
        self.checkbox_url = self.grid2s.add(egg.gui.CheckBox(
            'Open URL', autosettings_path='checkbox_url', 
            tip='Open the specified URL in your browser.'))
        
        # upload button
        self.button_upload = self.grid2s.add(egg.gui.Button(
            'Go!', tip='Packages the required server data, uploads, restarts the server, cleans up the local files.', 
            signal_clicked=self._button_upload_clicked), alignment=0)
        self.button_upload.set_style(self.style_fancybutton)
        self.grid2s.set_column_stretch(7)

        ###################
        # Load tracks and cars
        self.button_refresh.click()
        
        # Do this after updating carsets to avoid issues
        self.combo_carsets.signal_changed.connect(self._combo_carsets_changed)

        ###################
        # Update gui
        self._combo_mode_changed(None)

        self._init = False

        ######################
        # Show it no more commands below this.
        self.window.show(blocking)

    def save_gui(self):
        """
        Saves the GUI config that isn't auto-saved already.
        """
        if self._init: return
        
        gui = dict(
            combo_tracks  = self.combo_tracks.get_text(),
            combo_layouts = self.combo_layouts.get_text(),
            combo_carsets = self.combo_carsets.get_text(),
            list_cars     = self.get_selected_cars()
        )
        print('\nSaving GUI:')
        pprint.pprint(gui)
        json.dump(gui, open('gui.json', 'w'), indent=2)

    def load_gui(self):
        """
        Loads gui.json to fill in the config that is not auto-saved already.
        """
        print('\nLoading GUI')
        gui = load_json('gui.json')
        if not gui: return

        pprint.pprint(gui)

        # Combos
        try:    self.combo_tracks.set_text(gui['combo_tracks'])
        except Exception as e: print('combo_tracks', e)
        try:    self.combo_layouts.set_text(gui['combo_layouts'], block_signals=True)
        except Exception as e: print('combo_layouts', e)
        try:    self.combo_carsets.set_text(gui['combo_carsets'])
        except Exception as e: print('combo_carsets', e)
        
        # List items
        self.set_list_cars_selection(gui['list_cars'])
        print('Loaded.')

    def _checkbox_clean_changed(self, e=None):
        """
        Warn the user about this.
        """
        if self.checkbox_clean():
            msg = egg.pyqtgraph.QtGui.QMessageBox()
            msg.setIcon(egg.pyqtgraph.QtGui.QMessageBox.Information)
            msg.setText("WARNING: After uploading, this step will remotely "+
                        "delete all content from the following folders:")
            msg.setInformativeText(
                self.text_remote.get_text()+'/content/cars/\n'+
                self.text_remote.get_text()+'/content/tracks/')
            msg.setWindowTitle("HAY!")
            msg.setStandardButtons(egg.pyqtgraph.QtGui.QMessageBox.Ok)
            msg.exec_()
        
    def _list_cars_changed(self, e=None):
        """
        Just set the carset combo when anything changes.
        """
        self.combo_carsets(0)
        self.save_gui()

    def _combo_mode_changed(self,e):
        """
        Called when the server mode has changed. Just hides / shows the
        relevant settings.
        """
        print('Mode changed')
        premium = self.combo_mode.get_index() == 1
        self.label_remote_championship.hide(premium)
        self.text_remote_championship .hide(premium)

    def _button_upload_clicked(self,e):
        """
        Uploads the current configuration to the server.
        """
        self.log('\n------- GO TIME! --------')

        # Pre-command
        if self.text_precommand().strip() != '':
            self.log('Running pre-command')
            if self.system(self.text_precommand()): return

        # Make sure it's clean
        if os.path.exists('uploads'): rmtree('uploads')
        if os.path.exists('uploads.7z'): os.remove('uploads.7z')

        # Generate the appropriate config files
        if self.checkbox_modify(): 
            if self.combo_mode() == 0: self.generate_acserver_cfg()
            else:                      self.generate_acsm_cfg()
        else: self.log('*Skipping server config')

        # Collect and package all the data
        if self.checkbox_package():
    
            # get the tracks and cars
            track = self.combo_tracks.get_text() # Track directory
            cars  = self.get_selected_cars()     # List of car directories
    
            # Make sure we have at least one car
            if len(cars) == 0:
                self.log('No cars selected?')
                return
    
            # Make sure we have a track
            if track == '':
                self.log('No track selected?')
                return
    
            # COPY EVERYTHING TO TEMP DIRECTORY

            # Cars: we just need data dir and data.acd (if present)
            self.log('Collecting cars')
            for car in cars:
                self.log('  '+ self.cars[car])
                self.collect_assetto_files(os.path.join('cars',car))
    
            # Copy over the carsets folder too.
            shutil.copytree('carsets', os.path.join('uploads','carsets'))

            # Track
            self.log('Collecting track')
            self.log('  '+track)
            self.collect_assetto_files(os.path.join('tracks', track))

        # Package not checked
        else: self.log('*Skipping package')


        
        ####################################
        # SERVER STUFF
        
        # Server info
        login   = self.text_login.get_text()
        port    = self.text_port .get_text()
        pem     = os.path.abspath(self.text_pem.get_text())
        remote  = self.text_remote.get_text()
        stop    = self.text_stop.get_text()    # For acsm
        start   = self.text_start.get_text()   # For acsm
        monitor = self.text_monitor.get_text() 

        # Upload the main assetto content
        if self.checkbox_upload():
            
            # Stop server
            if self.checkbox_restart() and stop != '':
                self.log('Stopping server...')
                c = 'ssh -p '+port+' -i "'+pem+'" '+login+' "'+stop+'"' 
                if self.system(c): return
                
            else: self.log('*Skipping server stop')

            # Start the upload process
            self.log('Uploading content...')
    
            # Make sure we don't bonk the system with rm -rf
            if not remote.lower().find('assetto') >= 0:
                self.log('Yeah, sorry, to avoid messing with something unintentionally, we enforce that your remote path have the word "assetto" in it.')
                return
    
            # If we have uploads to compress
            if os.path.exists('uploads'):
                # Compress the files we gathered (MUCH faster upload)
                self.log('  Compressing uploads.7z')
                os.chdir('uploads')
                c = '7z a ../uploads.7z *'
                if self.system(c): 
                    os.chdir('..')
                    return
                os.chdir('..')
            
                self.log('  Uploading uploads.7z...')
                c = 'scp -P '+port+' -i "' + pem + '" uploads.7z '+login+':"'+remote+'"'
                if self.system(c): return
    
                # If we're cleaning...
                if self.checkbox_clean():
                    self.log('  Cleaning out old content...')
                    c = 'ssh -p '+port+' -i "'+pem+'" '+login+' rm -rf ' + remote + '/content/cars/* ' + remote + '/content/tracks/*'
                    if self.system(c): return
    
                # Remote extract
                self.log('  Extracting remote uploads.7z...')
                c = 'ssh -p '+port+' -i "'+pem+'" '+login+' 7z x -aoa ' + remote + '/uploads.7z' + ' -o' + remote
                if self.system(c): return

                self.log('  Cleaning up')                
                rmtree('uploads')
                if os.path.exists('uploads.7z'): os.remove('uploads.7z')
            
            # If we made a championship.json
            if self.checkbox_modify() and self.combo_mode()==1 and os.path.exists('championship.json'):
                # Upload it
                self.log('  Uploading championship.json...')
                c = 'scp -P '+port+' -i "' + pem +'" championship.json '+ login+':"'+self.text_remote_championship()+'"'
                if self.system(c): return
                
            # Start server
            if self.checkbox_restart() and start != '':
                self.log('Starting server...')
                c = 'ssh -p '+port+' -i "'+pem+'" '+login+' "'+start+'"' 
                if self.system(c): return
            else: self.log('*Skipping server start')

            # Start server
            if self.checkbox_monitor() and monitor != '':
                self.log('Restarting monitor...')
                c = 'ssh -p '+port+' -i "'+pem+'" '+login+' "'+monitor+'"' 
                if self.system(c): return
            else: self.log('*Skipping monitor restart')


        # No upload
        else: self.log('*Skipping upload')

        # Copy the nice cars list to the clipboard
        if self.combo_mode() == 0:
            pyperclip.copy(self.get_nice_selected_cars_string())
            self.log('List copied to clipboard')
            
        # Forward to the supplied URL
        if self.checkbox_url() and self.text_url() != '':
            self.log('Opening supplied URL...')
            webbrowser.open(self.text_url())
    
        # No URL popup
        else: self.log('*Skipping URL')

        # Post-command
        if self.text_postcommand().strip() != '':
            self.log('Running post-command')
            if self.system(self.text_postcommand()): return

        self.log('Done! Hopefully!')

    def collect_assetto_files(self, source_folder):
        """
        Copies all the required files from the supplied content folder. 
        source_folder should be something like 'tracks/imola' or 'cars/ks_meow'
        """
        source_folder = os.path.join(self.text_local(),'content',source_folder)
        
        # File extensions we should copy over. ACSM needs a few extra heavies.
        filetypes = ['ini', 'lut', 'rto', 'acd', 'json']
        if self.combo_mode.get_index() == 1:
            filetypes = filetypes + ['ai', 'bin', 'jpg', 'png']
        
        # Walk through the directory picking up the key files
        print('collecting', source_folder)
        for root, dirs, files in os.walk(source_folder):
            for file in files:
                if os.path.splitext(file)[-1][1:] in filetypes:
                    source      = os.path.join(root,file)
                    destination = os.path.join('uploads', source[len(self.text_local())+1:])
                    
                    # Copy it over, making dirs first
                    os.makedirs(os.path.dirname(destination), exist_ok=True)
                    try: shutil.copy(source, destination, follow_symlinks=True)
                    except Exception as e: print(e)
    
            

    def log(self, *a):
        """
        Logs it.
        """
        a = list(a)
        for n in range(len(a)): a[n] = str(a[n])
        self.text_log.append_text(' '.join(a))
        self.window.process_events()

    def system(self, command):
        """
        Runs a system command and logs it.
        """
        print(command)
        r = os.system(command)
        if r!=0: 
            self.log('  UH OH! See console!')
            return r
        return 0

    def get_nice_selected_cars_string(self):
        """
        Returns and copies a string to the clipboard a list
        for pasting into the google sheet data validation column.
        """

        # Get a string of nice car names for pasting into the data validation
        s = self.combo_carsets.get_text()
        for d in self.get_selected_cars():
            s = s+'\n'+self.cars[d]

        # copy this to the clipboard
        pyperclip.copy(s)
        return s

    def _combo_tracks_changed(self,e):
        print('_combo_tracks_changed')
        
        track = self.combo_tracks.get_text()
        if track == '': return

        # Update the layouts selector
        self.combo_layouts.clear()

        # Search for models_*.ini
        paths = glob.glob(os.path.join(self.text_local(), 'content', 'tracks', track, 'models_*.ini'))
        for path in paths:
            layout = os.path.split(path)[-1].replace('models_','').replace('.ini','')
            self.combo_layouts.add_item(layout)
        
        # Get the initial data!
        self._combo_layouts_changed(True)
        
        self.save_gui()

    def _combo_layouts_changed(self,e):
        print('_combo_layouts_changed')
        # Paths
        local  = self.text_local()
        track  = self.combo_tracks.get_text()
        layout = self.combo_layouts.get_text()

        # Path to ui.json
        if layout == '': p = os.path.join(local,'content','tracks',track,'ui',       'ui_track.json')
        else:            p = os.path.join(local,'content','tracks',track,'ui',layout,'ui_track.json')
        if not os.path.exists(p): return

        # Load it and get the pit number
        self.track = load_json(p)
        self.label_pitboxes('('+self.track['pitboxes']+' pit boxes)')
        
        self.save_gui()

    def _combo_carsets_changed(self,e): 
        print('_combo_carsets_changed')
        self.button_load.click()
        self.save_gui()

    def upload_file(self, path):
        """
        Just uplaods a file relative to this script's working directory.
        """
        # Server info
        login  = self.text_login.get_text()
        port   = self.text_port .get_text()
        pem    = os.path.abspath(self.text_pem.get_text())
        remote = self.text_remote.get_text()

        # Upload path
        c = 'scp -P '+port+' -i "' + pem + '" "'+path+'" '+login+':"'+remote+'"'
        return self.system(c)

    def _button_delete_clicked(self,e):
        """
        Deletes the selected carset.
        """
        # Special case: first element in combo box is new carset
        if self.combo_carsets.get_index() == 0: return

        # remove it
        os.remove(os.path.join('carsets', self.combo_carsets.get_text()))

        # Select the zeroth
        self.combo_carsets(0)

        # Rebuild
        self.update_carsets()

    def set_list_cars_selection(self, selected):
        """
        Selects the specified list of cars.
        """
        # Disconnect the update signal until the end
        self.list_cars.itemSelectionChanged.disconnect()

        # Update the list selection
        self.list_cars.clearSelection()
        for s in selected:
            s = s.strip()
            if s != '':
                try:    self.list_cars.findItems(s, egg.pyqtgraph.QtCore.Qt.MatchExactly)[0].setSelected(True)
                except: self.log('\nWARNING: '+s+' not in list')
        
        # Reconnect
        self.list_cars.itemSelectionChanged.connect(self._list_cars_changed)
                

    def _button_load_clicked(self,e):
        """
        Load the selected carset.
        """
        print('Load carset button clicked')

        # Special case: first element in combo box is new carset
        if self.combo_carsets.get_index() == 0: return

        # Get teh path associated with this
        path = os.path.join('carsets', self.combo_carsets.get_text())
        if not os.path.exists(path) or os.path.isdir(path): return
        
        # Load it.
        f = open(path, 'r', encoding="utf8")
        selected = f.read().splitlines()
        f.close()

        self.set_list_cars_selection(selected)
        
        self.save_gui()
        
    def _button_save_clicked(self,e):
        """
        Save the carset.
        """

        # Special case: first element in combo box is new carset
        if self.combo_carsets.get_index() == 0:
            name, ok = egg.pyqtgraph.QtGui.QInputDialog.getText(egg.pyqtgraph.QtGui.QWidget(), 'New Carset', 'Name your carset:')
            if not ok or name.strip() == '': return
            
            # Add it to the combo and select it
            self.combo_carsets.add_item(name)

        # Otherwise use what's there.
        else: name = self.combo_carsets.get_text()

        # Get rid of white space
        name = name.strip()

        # Write the file
        f = open(os.path.join('carsets', name), 'w', encoding="utf8")
        for car in self.get_selected_cars(): f.write(car+'\n')
        f.close()
        
        # Make sure it's selected.
        self.combo_carsets.set_text(name)


    def _button_browse_pem_clicked(self, e):
        """
        Pop up the directory selector.
        """
        path = egg.dialogs.load('Show me the *.pem file, Johnny Practicehole', default_directory='assetto_pem')
        if(path): self.text_pem(path)

    def _button_browse_local_clicked(self, e):
        """
        Pop up the directory selector.
        """
        path = egg.dialogs.select_directory('Select the Assetto Corsa directory, apex-nerd.', default_directory='assetto_local')
        if(path):
            self.text_local(path)
            self.button_refresh.click()

    def _button_refresh_clicked(self, e):
        """
        Refresh cars and tracks
        """
        # Load the carsets list
        self.update_carsets()
        
        # Search for tracks
        self.update_tracks()

        # Search for cars
        self.update_cars()

        # Load the combo boxes etc to the last state
        self.load_gui()

        # Reload the carset
        self.button_load.click()
        

    def get_server_cfg_source(self):
        """
        Returns 'server_cfg.ini.private' if it exists, or 'server_cfg.ini'.
        """
        if os.path.exists('server_cfg.ini.private'): return 'server_cfg.ini.private'
        else: return 'server_cfg.ini'

    def get_entry_string(self, slot, model='', skin=''):
        """
        Assembles an entry string for entry_list.ini.
        """
        s =     '[CAR_'+str(slot)+']\n'
        s = s + 'MODEL='+str(model)+'\n'
        s = s + 'SKIN='+str(skin)+'\n'
        s = s + 'SPECTATOR_MODE=0\n'
        s = s + 'DRIVERNAME=\n'
        s = s + 'TEAM=\n'
        s = s + 'GUID=\n'
        s = s + 'BALLAST=0\n'
        s = s + 'RESTRICTOR=0'
        return s

    def generate_acsm_cfg(self):
        """
        Downloads the specified championship json, modifies it, but does not 
        re-upload.
        """
        self.log('Generating acsm config')
        
        # Server info
        login   = self.text_login.get_text()
        port    = self.text_port .get_text()
        pem     = os.path.abspath(self.text_pem.get_text())

        # Load the championship from the server        
        self.log('  Downloading championship.json...')
        c = 'scp -P '+port+' -i "' + pem +'" '+ login+':"'+self.text_remote_championship()+'" championship.json'
        self.system(c)
        c = self.championship = load_json('championship.json')

        # Name
        c['Name'] = self.combo_carsets.get_text()+' at '+self.track['name']
        
        # Reset the signup form
        c['SignUpForm']['Responses'] = []
        
        # One car class for simplicity
        x = c['Classes'][0]
        x['Name'] = self.combo_carsets.get_text() 
        x['Entrants'] = dict()
        c['Events'][0]['EntryList'] = dict()
    
        # Fill the pitboxes / slots
        N = self.number_slots()
        if 'pitboxes' not in self.track: self.track['pitboxes'] = 0
        N = min(N, int(self.track['pitboxes']))
        for n in range(N):
            x['Entrants']['CAR_'+str(n+1)] = {
                "InternalUUID": "%08d-0000-0000-0000-000000000000" % (n+1),
                "PitBox": n,
                "Name": "",
                "Team": "",
                "GUID": "",
                "Model": "any_car_model",
                "Skin": "random_skin",
                "ClassID": "00000000-0000-0000-0000-000000000000",
                "Ballast": 0,
                "SpectatorMode": 0,
                "Restrictor": 0,
                "FixedSetup": "",
                "ConnectAsSpectator": False,
                "IsPlaceHolder": False}
            c['Events'][0]['EntryList']['CAR_'+str(n)] = dict(x['Entrants']['CAR_'+str(n+1)])
     
        # Update the cars
        x['AvailableCars'] = self.get_selected_cars()
        
        # One event for simplicity
        e = c['Events'][0]
        
        # Again with the cars
        e['RaceSetup']['Cars']  = ';'.join(self.get_selected_cars())
        e['RaceSetup']['Track'] = self.combo_tracks.get_text()
        e['RaceSetup']['TrackLayout'] = self.combo_layouts.get_text()
        e['RaceSetup']['LegalTyres'] = "V;H;M;S;ST;SM;SV" # JACK: UNPACK AND SCRAPE DATA.ACD? GROSS!!
        
        # Write the new file.
        self.log('  Updating championship.json')
        with open('championship.json','w', encoding="utf8") as f: json.dump(self.championship, f, indent=2)



    def generate_acserver_cfg(self):
        """
        Writes the entry_list.ini and server_cfg.ini, and race.json for 
        the vanilla / steam acServer.
        """
        self.log('Generating acServer config')

        # Get the selected car directories
        cars = self.get_selected_cars()
        if len(cars)==0:
            self.log('OOPS: generate_acserver_cfg() with no cars selected!')
            return

        # Get the selected track directory
        track = self.combo_tracks.get_text()
        if track == '':
            self.log('OOPS: generate_acserver_cfg() with no track selected!')

        #########################
        # entry_list.ini
        self.log('  entry_list.ini')
        
        # now fill the slots
        entries = []
        m = 0 # car index
        N = self.number_slots()
        if 'pitboxes' not in self.track: self.track['pitboxes'] = 0
        N = min(N, int(self.track['pitboxes']))
        for n in range(0, N):

            # Get the next car dir
            car = cars[m]

            # Get the current random skin
            skin = self.skins[car][random.randrange(len(self.skins[car]))]

            # Append the entry
            entries.append(self.get_entry_string(n, car, skin))

            # Cyclic iterate
            m += 1
            if m >= len(cars): m = 0

        # Get the full string!
        s = '\n\n'.join(entries) + '\n'
        print('\nENTRIES:\n\n'+s)

        # Save entries
        cfg = os.path.join('uploads', 'cfg')
        os.makedirs(cfg, exist_ok=True)

        self.log('  entry_list.ini')
        f = open(os.path.join(cfg, 'entry_list.ini'), 'w', encoding="utf8")
        f.write(s)
        f.close()

        #######################
        # server_cfg.ini

        # We have to add the selected cars and track to server_cfg.ini before uploading
        f = open(self.get_server_cfg_source(), 'r', encoding="utf8"); ls = f.readlines(); f.close()
        for n in range(len(ls)):

            # Get the key for this line
            key = ls[n].split('=')[0].strip()

            # Add the list of cars
            if key == 'CARS': ls[n] = 'CARS='+';'.join(cars)+'\n'

            # Add the track
            elif key == 'TRACK': ls[n] = 'TRACK='+track+'\n'

            # Layout
            elif key == 'CONFIG_TRACK': ls[n] = 'CONFIG_TRACK='+self.combo_layouts.get_text()+'\n'

            # Slots
            elif key == 'MAX_CLIENTS': ls[n] = 'MAX_CLIENTS='+str(N)+'\n'

        self.log('  server_cfg.ini ('+str(N)+' pit boxes)')
        f = open(os.path.join(cfg, 'server_cfg.ini'), 'w', encoding="utf8");
        f.writelines(ls);
        f.close()

        # Prep the race.json file, which is used to restart the server
        # on race night.
        self.log('Prepping race data:')
        self.race_json = dict()

        # CARSET NAME
        self.log ('  carset')
        if self.combo_carsets() > 0: self.race_json['carset'] = self.combo_carsets.get_text()
        else:                        self.race_json['carset'] = None

        # CARS DICTIONARY (Lookup by nice name)
        self.log('  cars')
        self.race_json['cars'] = dict()
        for c in cars: self.race_json['cars'][self.cars[c]] = c
        #json.dump(cars_dictionary, open(os.path.join('uploads', 'cars.txt'), 'w'))

        # SKINS
        self.log('  skins')
        self.race_json['skins'] = dict()
        for c in cars: self.race_json['skins'][c] = self.skins[c]
        #json.dump(skins, open(os.path.join('uploads', 'skins.txt'), 'w'))

        # TRACK
        self.log('  track')
        self.race_json['track'] = self.track
        self.race_json['track']['directory'] = track.strip()

        # Dump
        self.log('Dumping to race.json')
        json.dump(self.race_json, open(os.path.join('uploads', 'race.json'), 'w', encoding="utf8"), indent=2, sort_keys=True)



    def get_selected_cars(self):
        """
        Returns a list of selected cars.
        """
        a = []
        for x in self.list_cars.selectedItems(): a.append(x.text())
        a.sort()
        return a

    def update_carsets(self):
        """
        Searches carsets directory and updates combo box.
        """
        self.log('Updating carsets...')
        # Clear existing
        self.combo_carsets.clear()
        self.combo_carsets.add_item('[New Carset]')

        paths = glob.glob(os.path.join('carsets','*'))
        for path in paths: self.combo_carsets.add_item(os.path.split(path)[-1])

    def update_cars(self):
        """
        Searches through the current assetto directory for all cars, skins, etc.
        """
        print('update_cars')
        
        # Clear out the list
        self.list_cars.clear()

        # Dictionary to hold all the model names
        self.cars = dict()
        self.skins = dict()

        # Get all the car paths
        paths = glob.glob(os.path.join(self.text_local(), 'content', 'cars', '*'))
        self.log('Updating cars...')
        for path in paths:

            # Get the car's directory name
            dirname = os.path.split(path)[-1]

            # Make sure it exists.
            path_json = os.path.join(path, 'ui', 'ui_car.json')
            if not os.path.exists(path_json): continue

            # Get the fancy car name (the jsons are not always well formatted, so I have to manually search!)
            f = codecs.open(path_json, 'r', encoding='utf-8')
            s = f.read()
            f.close()

            # Find the index of "name" as the starting point
            i1 = s.find('"name"')
            if i1 >= 0:
                i2 = s.find('"', i1+6)
                if i2 >= 0:
                    i3 = s.find('"', i2+1)
                    if i3 >= 0:
                        try: s[i2+1:i3] + ': ' + dirname
                        except: print(' *[CANNOT PRINT / UNICODE ISSUE]: '+dirname)
                        self.cars[dirname] = s[i2+1:i3]

            # Store the list of skins and the index
            self.skins[dirname] = os.listdir(os.path.join(path, 'skins'))

        # Sort the car directories and add them to the list.
        self.car_directories = list(self.cars.keys())
        self.car_directories.sort()
        for n in self.car_directories: egg.pyqtgraph.QtGui.QListWidgetItem(n, self.list_cars)

    def update_tracks(self):
        """
        Searches through the assetto directory for all the track folders
        """
        print('update_tracks')
        # Clear existing
        self.combo_tracks.clear()

        # Get all the paths
        self.log('Updating tracks...')
        paths = glob.glob(os.path.join(self.text_local(), 'content', 'tracks', '*'))
        paths.sort()
        for path in paths:
            self.combo_tracks.add_item(os.path.split(path)[-1])




# Start the show!
self = uploader()